
use std::fs;
use std::path::{Path, PathBuf};
use std::collections::HashMap;
use std::sync::Arc;

use glium;

use glium::{glutin, Surface};
use glium::index::PrimitiveType;
use glium::glutin::{VirtualKeyCode, WindowEvent};

use image;

pub mod errors {
    use std::io;
    use glium::texture;

    error_chain!{
        foreign_links {
            Io(io::Error) #[doc = "Error during IO"];
            TextureCreation(texture::TextureCreationError);
        }
    }
}

use self::errors::*;

pub struct ImageCache {
    dir_path: PathBuf,
    cache: HashMap<PathBuf, (fs::Metadata, Arc<glium::texture::SrgbTexture2d>)>,
    curr_texture: Option<(PathBuf, Arc<glium::texture::SrgbTexture2d>)>,
}

/// This is a store for the supported images loaded from a folder
/// The basic idea is to have a few images already in the memory while an image is shown on the screen
impl ImageCache {
    /// # Arguemnts
    /// * `capacity` - Kilobytes. The last image loaded will be the one at which the allocated memory reaches or exceeds capacity
    pub fn new(capacity: usize) -> ImageCache {
        ImageCache {
            dir_path: PathBuf::new(),
            cache: HashMap::new(),
            curr_texture: None,
        }
    }

    pub fn load_specific(
        &mut self,
        display: &glium::Display,
        path: &str,
    ) -> Result<Arc<glium::texture::SrgbTexture2d>> {
        use glium::texture::{RawImage2d, SrgbTexture2d};

        let path = Path::new(path).canonicalize()?;
        let metadata = fs::metadata(path.clone())?;

        use std::collections::hash_map::Entry;
        // Check if it is in the cache
        let map_entry = self.cache.entry(path.clone());
        if let Entry::Occupied(ref entry) = map_entry {
            if entry.get().0.modified().unwrap() == metadata.modified().unwrap() {
                return Ok(entry.get().1.clone());
            }
        };

        let canonical = path.canonicalize()?;
        self.dir_path = canonical.parent().unwrap().to_owned(); // It absolutely must have a parent if it was a file

        let image = image::open(path).unwrap().to_rgba();
        let image_dimensions = image.dimensions();
        let image = RawImage2d::from_raw_rgba(image.into_raw(), image_dimensions);

        // Please note the unwrap followed by the Some re-wrap.
        // It is expected behaviour not to have a filename specified as argument
        // However it is not expected to fail loading the image
        let result = SrgbTexture2d::with_mipmaps(
            display,
            image,
            glium::texture::MipmapsOption::AutoGeneratedMipmapsMax(4),
        )?;

        let result = Arc::new(result);
        match map_entry {
            Entry::Occupied(mut entry) => {
                entry.get_mut().0 = metadata;
                entry.get_mut().1 = result.clone();
            }
            Entry::Vacant(entry) => {
                entry.insert((metadata, result.clone()));
            }
        }
        Ok(result)
    }
}
