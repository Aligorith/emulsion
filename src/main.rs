#![windows_subsystem = "windows"]

#[macro_use]
extern crate glium;
extern crate image;

use std::env;

use glium::{glutin, Surface};
use glium::index::PrimitiveType;
use glium::glutin::{Api, GlRequest, VirtualKeyCode, WindowEvent};


#[derive(Copy, Clone)]
struct Vertex {
    position: [f32; 2],
    tex_coords: [f32; 2],
}

implement_vertex!(Vertex, position, tex_coords);


struct MainWindow {
    display: glium::Display,

    transform: [[f32; 4]; 4],
    vertex_buffer: glium::VertexBuffer<Vertex>,
    index_buffer: glium::IndexBuffer<u16>,
    program: glium::Program,
    image_texture: Option<glium::texture::SrgbTexture2d>
}


impl MainWindow {
    fn init(events_loop: &glutin::EventsLoop) -> MainWindow {
        let window = glutin::WindowBuilder::new()
            .with_title("E M U L S I O N")
            .with_dimensions(512, 512)
            //.with_decorations(true)
            .with_visibility(true);
        //let context = glutin::ContextBuilder::new().with_gl(GlRequest::Specific(Api::OpenGl, (3, 1)));
        let context = glutin::ContextBuilder::new().with_gl_profile(glutin::GlProfile::Core);
        let display = glium::Display::new(window, context, events_loop).unwrap();

        // Clear the screen right at the start so that the user sees a black window instead
        // of white while the image is loading.
        {
            let mut target = display.draw();
            target.clear_color(0.0, 0.0, 0.0, 0.0);
            target.finish().unwrap();
        }

        let image_texture = if let Some(img_path) = env::args().skip(1).next() {
            let image = image::open(img_path.as_str()).unwrap().to_rgba();
            let image_dimensions = image.dimensions();
            let image = glium::texture::RawImage2d::from_raw_rgba(image.into_raw(), image_dimensions);
            //Some(glium::texture::SrgbTexture2d::new(&display, image).unwrap())

            let image = glium::texture::SrgbTexture2d::with_mipmaps(&display, image, glium::texture::MipmapsOption::AutoGeneratedMipmapsMax(4)).unwrap();
            Some(image)
        } else {
            None
        };

        // building the vertex buffer, which contains all the vertices that we will draw
        let vertex_buffer = {

            glium::VertexBuffer::new(
                &display,
                &[
                    Vertex {
                        position: [-1.0, -1.0],
                        tex_coords: [0.0, 1.0],
                    },
                    Vertex {
                        position: [-1.0, 1.0],
                        tex_coords: [0.0, 0.0],
                    },
                    Vertex {
                        position: [1.0, 1.0],
                        tex_coords: [1.0, 0.0],
                    },
                    Vertex {
                        position: [1.0, -1.0],
                        tex_coords: [1.0, 1.0],
                    },
                ],
            ).unwrap()
        };

        // building the index buffer
        let index_buffer =
            glium::IndexBuffer::new(&display, PrimitiveType::TriangleStrip, &[1 as u16, 2, 0, 3])
                .unwrap();

        // compiling shaders and linking them together
        let program = program!(&display,
            140 => {
                vertex: "
                    #version 140
                    uniform mat4 matrix;
                    in vec2 position;
                    in vec2 tex_coords;
                    out vec2 v_tex_coords;
                    void main() {
                        gl_Position = matrix * vec4(position, 0.0, 1.0);
                        v_tex_coords = tex_coords;
                    }
                ",

                fragment: "
                    #version 140
                    uniform sampler2D tex;
                    in vec2 v_tex_coords;
                    out vec4 f_color;
                    void main() {
                        f_color = texture(tex, v_tex_coords);
                    }
                "
            },

            110 => {
                vertex: "
                    #version 110
                    uniform mat4 matrix;
                    attribute vec2 position;
                    attribute vec2 tex_coords;
                    varying vec2 v_tex_coords;
                    void main() {
                        gl_Position = matrix * vec4(position, 0.0, 1.0);
                        v_tex_coords = tex_coords;
                    }
                ",

                fragment: "
                    #version 110
                    uniform sampler2D tex;
                    varying vec2 v_tex_coords;
                    void main() {
                        gl_FragColor = texture2D(tex, v_tex_coords);
                    }
                ",
            },

            100 => {
                vertex: "
                    #version 100
                    uniform lowp mat4 matrix;
                    attribute lowp vec2 position;
                    attribute lowp vec2 tex_coords;
                    varying lowp vec2 v_tex_coords;
                    void main() {
                        gl_Position = matrix * vec4(position, 0.0, 1.0);
                        v_tex_coords = tex_coords;
                    }
                ",

                fragment: "
                    #version 100
                    uniform lowp sampler2D tex;
                    varying lowp vec2 v_tex_coords;
                    void main() {
                        gl_FragColor = texture2D(tex, v_tex_coords);
                    }
                ",
            },
        ).unwrap();

        let transform = [
            [1.0, 0.0, 0.0, 0.0],
            [0.0, 1.0, 0.0, 0.0],
            [0.0, 0.0, 1.0, 0.0],
            [0.0, 0.0, 0.0, 1.0f32]
        ];

        MainWindow {
            display,

            transform,
            vertex_buffer,
            index_buffer,
            program,
            image_texture
        }
    }

    fn start_event_loop(&mut self, events_loop: &mut glutin::EventsLoop) {
        let mut dragging = false;
        let mut last_mouse_pos = (0f64, 0f64);
        let mut drag_start_pos = (0f64, 0f64);

        // the main loop
        events_loop.run_forever(|event| {
            match event {
                glutin::Event::WindowEvent { event, .. } => match event {
                    // Break from the main loop when the window is closed.
                    WindowEvent::Closed => return glutin::ControlFlow::Break,
                    WindowEvent::KeyboardInput { input, .. } => {
                        if input.virtual_keycode == Some(VirtualKeyCode::Escape) {
                            return glutin::ControlFlow::Break;
                        }
                    }
                    WindowEvent::MouseInput { state, button, .. } => {
                        if button == glutin::MouseButton::Left {
                            dragging = state == glutin::ElementState::Pressed;
                            drag_start_pos = last_mouse_pos;
                        }
                    },
                    WindowEvent::CursorMoved { position, .. } => {
                        if dragging {
                            let offset = (position.0 - drag_start_pos.0, position.1 - drag_start_pos.1);
                            let window_pos = self.display.gl_window().get_position().unwrap();
                            /*
                            self.display.gl_window().set_position(
                                window_pos.0 + offset.0 as i32,
                                window_pos.1 + offset.1 as i32,
                            );
                            */

                        }
                        last_mouse_pos = position;
                    }

                    // Redraw the triangle when the window is resized.
                    WindowEvent::Resized(window_w, window_h) => {
                        if let Some(ref image) = self.image_texture {
                            let img_w = image.width();
                            let img_h = image.height();

                            let img_ratio = img_w as f32 / img_h as f32;
                            let window_ratio = window_w as f32 / window_h as f32;

                            let mut scale_x = 1f32;
                            let mut scale_y = 1f32;

                            if img_ratio < window_ratio {
                                scale_x = ((img_ratio / window_ratio) * window_w as f32).floor() / window_w as f32;
                            } else {
                                scale_y = ((window_ratio / img_ratio) * window_h as f32).floor() / window_h as f32;
                            }

                            self.transform = [
                                [scale_x, 0.0, 0.0, 0.0],
                                [0.0, scale_y, 0.0, 0.0],
                                [0.0, 0.0, 1.0, 0.0],
                                [0.0, 0.0, 0.0, 1.0f32]
                            ];
                        }

                        self.draw()
                    },
                    _ => (),
                },
                _ => (),
            }
            glutin::ControlFlow::Continue
        });
    }

    fn draw(&self) {
        // drawing a frame
        let mut target = self.display.draw();
        target.clear_color(0.0, 0.0, 0.0, 0.0);
        if let Some(ref texture) = self.image_texture {
            // building the uniforms
            let uniforms = uniform! {
                matrix: self.transform,
                tex: texture.sampled().wrap_function(glium::uniforms::SamplerWrapFunction::Clamp)
            };
            target
                .draw(
                    &self.vertex_buffer,
                    &self.index_buffer,
                    &self.program,
                    &uniforms,
                    &Default::default(),
                )
                .unwrap();
        }
        target.finish().unwrap();
    }
}


fn main() {
    // I don't know how to Rust
    let mut events_loop = glutin::EventsLoop::new();
    let mut main_window = MainWindow::init(&events_loop);
    main_window.start_event_loop(&mut events_loop);
}
